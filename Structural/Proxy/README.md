## 代理模式
代理模式, 为其他对象提供一种代理以控制对这个对象的访问. 代理就像我们FQ那样, 正常网络请求到一些404网站, 但由于GFW干扰, 无法请求.
此时你需要通过一个代理服务器去请求, 然后把结果告诉你. 这些代理服务器和正常的都有请求动作, 因此抽象出一个接口, 这样所有正常都可以用代理去请求.

跟适配者模式不同, 适配者是接口不兼容才考虑适用, 张冠李戴的. 而代理模式是实现同一个接口, 但真实主题对象不想被外部可知, 所以采用代理.

维基百科:
> 一个代理，其最一般的形式，就是作为其它类的接口的一个类。代理就是一个包装或中介对象，客户通过调用它来访问幕后真正提供服务的对象。使用代理可以简单地转发到真实对象，也可以提供额外的逻辑。代理可以提供这些额外的功能，
   例如当在真实对象上的操作需要大量资源时进行缓存，或者对真实对象调用操作时先检查先决条件等

代理模式角色:
- Subject: 抽象主题角色, 定义了 RealSubject 和 Proxy 的共用接口, 这样就在任何使用 RealSubject 的地方都可以使用Proxy
- Proxy: 代理主题角色, 保存一个引用使得代理可以访问实体, 并提供一个与 Subject 接口相同的方法, 这样代理就可以用来替代实体
- RealSubject: 真实主题角色, 定义 Proxy 所代表的真实实体

适用环境:
- 远程代理：为对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在于不同地址空间的事实
- 虚拟代理：对于一些占用系统资源较多或者加载时间较长的对象，可以给这些对象提供一个虚拟代理，这样就可以达到性能的最优化。
- 安全代理：控制真实对象访问时的权限
- 缓冲代理：为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，从而可以避免某些方法的重复执行，优化

缺点:
- 实现代理模式需要额外的工作，有些代理模式的实现 非常复杂
- 由于在客户端和真实主题之间增加了代理对象，因此 有些类型的代理模式可能会造成请求的处理速度变慢。


   